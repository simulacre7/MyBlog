---
title: '30ë¶„ë§Œì— ë°°ìš°ëŠ” Rust'
date: '2022-04-02'
tags: ['rust', 'browser', 'low-level']
draft: false
summary: 'Rustì— ë¹ ë¥´ê²Œ ì…ë¬¸í•´ë³´ì!'
layout: PostSimple
bibliography: /2022-04-02/half-hour-rust.bib
canonicalUrl: https://tailwind-nextjs-starter-blog.vercel.app/blog/half-hour-rust/
---

> ğŸš§ ì•„ì§ ì‘ì„± ì¤‘ì¸ ê¸€ì…ë‹ˆë‹¤. ğŸš§

> ë‹¤ìŒ ê¸€ì€ Amos Wengerì˜ [A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)ë¥¼ ë²ˆì—­í•œ ê²ƒì…ë‹ˆë‹¤.
> ë¬¼ë¡  ì €ìì—ê²Œ í—ˆë½ì„ ë°›ì•˜ìŠµë‹ˆë‹¤.
> ë²ˆì—­ë¬¸ ë’¤ì˜ ì°¸ê³ ë¬¸í—Œì€ ì œê°€ ì‘ì„±í–ˆìŠµë‹ˆë‹¤.

ì´ ê¸€ì—ì„œ ìµœëŒ€í•œ ë§ì€ Rust ì½”ë“œ ì¡°ê°ë“¤ì„ ë‹¤ë£¨ê³ ì í•©ë‹ˆë‹¤.
ë…ìë“¤ì€ Rustì˜ ìˆ˜ ë§ì€ í‚¤ì›Œë“œì™€ ê¸°í˜¸ê°€ ê°ê° ì–´ë–¤ ì˜ë¯¸ë¥¼ ê°–ëŠ”ì§€ ì•Œê²Œ ë  ê²ƒì´ê³ ,
ì˜¨ë¼ì¸ì—ì„œ ë§ˆì£¼ì¹˜ëŠ” ëŒ€ë¶€ë¶„ì˜ Rust ì½”ë“œë¥¼ ì´í•´í•  ìˆ˜ ìˆê²Œ ë  ê²ƒì…ë‹ˆë‹¤.

letì€ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤:

```rust
let x; // declare "x"
x = 42; // assign 42 to "x"
```

í•œ ì¤„ë¡œ ì¤„ì—¬ì“¸ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:

```rust
let x = 42;
```

`:`ë¡œ íƒ€ì…ì„ ëª…ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ type annotationì´ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.

```rust
let x: i32; // `i32` is a signed 32-bit integer
x = 42;

// there's i8, i16, i32, i64, i128
//    also u8, u16, u32, u64, u128 for unsigned
```

ì´ê²ƒ ë˜í•œ í•œ ì¤„ë¡œ ì¤„ì—¬ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let x: i32 = 42;
```

ë³€ìˆ˜ì˜ ê°’ì„ ì´ˆê¸°í™”í•˜ê¸°ë„ ì „ì— ê·¸ ë³€ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤ë©´ ì»´íŒŒì¼ëŸ¬ê°€ ì—ëŸ¬ë¥¼ ì¼ìœ¼í‚µë‹ˆë‹¤.

```rust
let x;
foobar(x); // error: borrow of possibly-uninitialized variable: `x`
x = 42;
```

ì•„ë˜ì™€ ê°™ì´ ì´ˆê¸°í™”ë¥¼ ë¨¼ì €í•´ì•¼ í•©ë‹ˆë‹¤.

```rust
let x;
x = 42;
foobar(x); // the type of `x` will be inferred from here
```

ë°‘ì¤„ ê¸°í˜¸(undersocre) `_`ë¡œ ë³€ìˆ˜ ì´ë¦„ì„ ì§€ìœ¼ë©´ ê°’ì„ ë¬´ì‹œí•©ë‹ˆë‹¤.

```rust
// this does *nothing* because 42 is a constant
let _ = 42;

// this calls `get_thing` but throws away its result
let _ = get_thing();
```

ì´ë¦„ì´ `_`ë¡œ <i>ì‹œì‘</i>í•˜ëŠ” ê²½ìš°, ìœ„ì™€ëŠ” ë‹¤ë¥´ê²Œ ë™ì‘í•©ë‹ˆë‹¤.
ì´ ìš©ë²•ì€ ì»´íŒŒì¼ëŸ¬ê°€ ì´ ë³€ìˆ˜ê°€ ì‚¬ìš©ë˜ì§€ ì•Šë”ë¼ë„ ê²½ê³ í•˜ì§€ ì•Šê²Œë” í•©ë‹ˆë‹¤.

```rust
// we may use `_x` eventually, but our code is a work-in-progress
// and we just wanted to get rid of a compiler warning for now.
let _x = 42;
```

ì•„ë˜ì™€ ê°™ì€ ê²½ìš°ë¥¼ <i>shadow</i>ë¼ê³  í•©ë‹ˆë‹¤.

```rust
let x = 13;
let x = x + 3;
// using `x` after that line only refers to the second `x`,
// the first `x` no longer exists.
```

Rustì—ëŠ” íŠœí”Œ(tuples) ìë£Œêµ¬ì¡°ê°€ ìˆìŠµë‹ˆë‹¤. íŠœí”Œì€ "ê¸¸ì´ê°€ ê³ ì •ëœ, ì—¬ëŸ¬ íƒ€ì…ë“¤ì˜ ê°’ë“¤ì˜ ì§‘í•©"ì…ë‹ˆë‹¤.

```rust
let pair = ('a', 17);
pair.0; // this is 'a'
pair.1; // this is 17
```

`pair`ì˜ íƒ€ì…ì„ ëª…ì‹œí•˜ê³  ì‹¶ë‹¤ë©´, ì•„ë˜ì™€ ê°™ì´ ì“°ë©´ ë©ë‹ˆë‹¤.

```rust
let pair: (char, i32) = ('a', 17);
```

íŠœí”Œì€ êµ¬ì¡° ë¶„í•´ í• ë‹¹(destructuring assignment)ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
let (some_char, some_int) = ('a', 17);
// now, `some_char` is 'a', and `some_int` is 17
```

êµ¬ì¡° ë¶„í•´ í• ë‹¹ì€ ì–´ë–¤ í•¨ìˆ˜ê°€ íŠœí”Œì„ ë¦¬í„´í•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

```rust
let (left, right) = slice.split_at(middle);
```

êµ¬ì¡° ë¶„í•´ í• ë‹¹ì„ í•  ë•Œ, `_`ì„ ì‚¬ìš©í•´ì„œ íŠœí”Œì˜ ì¼ë¶€ë¥¼ ë¬´ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let (_, right) = slice.split_at(middle);
```

ì„¸ë¯¸ ì½œë¡ ì€ `;` ë¬¸ì¥(statement)ì˜ ëì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

```rust
let x = 3;
let y = 5;
let z = y + x;
```

ì´ ë§ì¸ì¦‰ìŠ¨ í•œ ë¬¸ì¥ì€ ì—¬ëŸ¬ ì¤„ì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ì•„ë˜ ì½”ë“œê°€ ì‹¤ì œë¡œ ì–´ë–¤ ì˜ë¯¸ë¥¼ ê°–ëŠ”ì§€ëŠ” ì¡°ê¸ˆ ìˆë‹¤ê°€ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤.

```rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
```

`fn`ì€ í•¨ìˆ˜ë¥¼ ì„ ì–¸í•©ë‹ˆë‹¤.

```rust
fn greet() {
    println!("Hi there!");
}
```

í™”ì‚´í‘œ `->` ê¸°í˜¸ë¥¼ í†µí•´ return íƒ€ì…ì„ ëª…ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
fn fair_dice_roll() -> i32 {
    4
}
```

í•œ ìŒì˜ ì¤‘ê´„í˜¸ë¡œ blockì„ ì„ ì–¸í•©ë‹ˆë‹¤. blockì€ ê³ ìœ ì˜ scopeë¥¼ ê°€ì§‘ë‹ˆë‹¤.

```rust
// This prints "in", then "out"
fn main() {
    let x = "out";
    {
        // this is a different `x`
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
```

Blockì€ í‘œí˜„ì‹ì´ê¸°ë„ í•©ë‹ˆë‹¤. ì´ ë§ì¸ì¦‰ìŠ¨ blockì€ ê²°ê³¼ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.

```rust
// this:
let x = 42;

// is equivalent to this:
let x = { 42 };
```

í•œ block ì•ˆì—ì„œ ì—¬ëŸ¬ ê°œì˜ ë¬¸ì¥ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let x = {
    let y = 1; // first statement
    let z = 2; // second statement
    y + z // this is the *tail* - what the whole block will evaluate to
};
```

í•¨ìˆ˜ì˜ ë§ˆì§€ë§‰ ë¶€ë¶„ì—ì„œ ì„¸ë¯¸ì½œë¡ ì„ ìƒëµí•˜ëŠ” ê²ƒì€ returnì„ ì˜ë¯¸í•©ë‹ˆë‹¤.
ë”°ë¼ì„œ ì•„ë˜ì˜ ë‘ í•¨ìˆ˜ëŠ” ë˜‘ê°™ì´ ë™ì‘í•©ë‹ˆë‹¤.

```rust
fn fair_dice_roll() -> i32 {
    return 4;
}

fn fair_dice_roll() -> i32 {
    4
}
```

`if` ì¡°ê±´ë¬¸ ë˜í•œ í‘œí˜„ì‹(expression)ì…ë‹ˆë‹¤.

```rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```

`match` ë˜í•œ í‘œí˜„ì‹ì…ë‹ˆë‹¤.

```rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}
```

ì (`.`)ì€ fieldì˜ ê°’ì„ ì ‘ê·¼í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

```rust
let a = (10, 20);
a.0; // this is 10

let amos = get_some_struct();
amos.nickname; // this is "fasterthanlime"
```

ë˜ëŠ” ë©”ì†Œë“œë¥¼ ë¶€ë¥´ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

```rust
let nick = "fasterthanlime";
nick.len(); // this is 14
```

Double-colon `::`ì€ ì ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

ì•„ë˜ ì˜ˆì‹œì—ì„œ, `std`ëŠ” <i>crate</i>(ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ ìœ ì‚¬í•œ ê°œë…)ì´ê³ , `cmp`ëŠ” <i>module</i>ì´ê³  `min`ì€ í•¨ìˆ˜ì´ë‹¤.

```rust
let least = std::cmp::min(3, 8); // this is 3
```

`use`ë¥¼ í†µí•´, ì´ë¦„ì„ ê°„ê²°í•˜ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
use std::cmp::min;

let least = min(7, 1); // this is 1
```

`use`ë¥¼ ì“¸ ë•Œ, ì¤‘ê´„í˜¸ëŠ” ë˜ ë‹¤ë¥¸ ì˜ë¯¸ë¥¼ ê°€ì§‘ë‹ˆë‹¤.

```rust
// this works:
use std::cmp::min;
use std::cmp::max;

// this also works:
use std::cmp::{min, max};

// this also works!
use std::{cmp::min, cmp::max};
```

ì™€ì¼ë“œì¹´ë“œ(`*`)ë¥¼ í†µí•´, ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì˜ ëª¨ë“  ìš”ì†Œë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
// this brings `min` and `max` in scope, and many other things
use std::cmp::*;
```

íƒ€ì… ë˜í•œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì…ë‹ˆë‹¤. ë”°ë¼ì„œ íƒ€ì…ì˜ ë©”ì†Œë“œëŠ” ì¼ë°˜ì ì¸ í•¨ìˆ˜ì²˜ëŸ¼ í˜¸ì¶œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let x = "amos".len(); // this is 4
let x = str::len("amos"); // this is also 4
```

`str`ì€ ì›ì‹œ íƒ€ì…ì´ì§€ë§Œ, ì›ì‹œ íƒ€ì…ì´ ì•„ë‹Œ íƒ€ì…ë“¤ë„ ë‹¤ìŒê³¼ ê°™ì´ í™œìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
// `Vec` is a regular struct, not a primitive type
let v = Vec::new();

// this is exactly the same code, but with the *full* path to `Vec`
let v = std::vec::Vec::new();
```

ìœ„ì™€ ê°™ì€ ì¼ì´ ê°€ëŠ¥í•œ ì´ìœ ëŠ” RustëŠ” ê° ëª¨ë“ˆì— ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œë¥¼ ì‚½ì…í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

```rust
use std::prelude::v1::*;
```

(Which in turns re-exports a lot of symbols, like Vec, String, Option and Result).

êµ¬ì¡°ì²´ëŠ” `struct` í‚¤ì›Œë“œë¡œ ì„ ì–¸ë©ë‹ˆë‹¤.

```rust
struct Vec2 {
    x: f64, // 64-bit floating point, aka "double precision"
    y: f64,
}
```

êµ¬ì¡°ì²´ëŠ” êµ¬ì¡°ì²´ ë¦¬í„°ëŸ´(strucut literals)ì„ í†µí•´, ê°’ì„ ì´ˆê¸°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, x: 4.0 };
// the order does not matter, only the names do
```

ë‹¤ë¥¸ êµ¬ì¡°ì²´ì—ì„œ ë‚˜ë¨¸ì§€ í•„ë“œë¥¼ ì´ˆê¸°í™”í•˜ëŠ” í¸ë¦¬í•œ ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.

```rust
let v3 = Vec2 {
    x: 14.0,
    ..v2
};
```

ì´ê²ƒì„ "struct update syntax"ì´ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤. ë§¨ ë§ˆì§€ë§‰ ë¶€ë¶„ì—ë§Œ í™œìš©ì´ ê°€ëŠ¥í•˜ë©°, ë’¤ì— `,`ê°€ ë¶™ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

ë‚˜ë¨¸ì§€ í•„ë“œëŠ” ëª¨ë“  í•„ë“œë¥¼ ì˜ë¯¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let v4 = Vec2 { ..v3 };
```

êµ¬ì¡°ì²´ë„ íŠœí”Œê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë¶„í•´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
let (left, right) = slice.split_at(middle);
```

ì•„ë˜ì²˜ëŸ¼ ë¶„í•´ í• ë‹¹ì„ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let v = Vec2 { x: 3.0, y: 6.0 };
let Vec2 { x, y } = v;
// `x` is now 3.0, `y` is now `6.0`
```

êµ¬ì¡° ë¶„í•´ í• ë‹¹ê³¼ struct update syntaxì„ ê°™ì´ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
let Vec2 { x, .. } = v;
// this throws away `v.y`
```

`if let` ë¬¸ë²•ì€ `match`ì™€ ë™ì¼í•œ ëª©ì ìœ¼ë¡œ, ë”ìš± ê°„ê²°í•˜ê²Œ ì“°ì…ë‹ˆë‹¤.

```rust
struct Number {
    odd: bool,
    value: i32,
}

fn main() {
    let one = Number { odd: true, value: 1 };
    let two = Number { odd: false, value: 2 };
    print_number(one);
    print_number(two);
}

fn print_number(n: Number) {
    if let Number { odd: true, value } = n {
        println!("Odd number: {}", value);
    } else if let Number { odd: false, value } = n {
        println!("Even number: {}", value);
    }
}

// this prints:
// Odd number: 1
// Even number: 2
```

`match`ì˜ ì¡°ê±´ìœ¼ë¡œ `if let`ì„ ì“¸ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

```rust
fn print_number(n: Number) {
    match n {
        Number { odd: true, value } => println!("Odd number: {}", value),
        Number { odd: false, value } => println!("Even number: {}", value),
    }
}

// this prints the same as before
```

ë‘ í•¨ìˆ˜ëŠ” ë˜‘ê°™ì´ ë™ì‘í•©ë‹ˆë‹¤. í›„ìê°€ í›¨ì”¬ ê°„ê²°í•œ í‘œí˜„ì…ë‹ˆë‹¤. `_`ì„ ì¨ì„œ "catch-all" íŒ¨í„´ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
fn print_number(n: Number) {
    match n {
        Number { value: 1, .. } => println!("One"),
        Number { value: 2, .. } => println!("Two"),
        Number { value, .. } => println!("{}", value),
        // if that last arm didn't exist, we would get a compile-time error
    }
}

fn print_number(n: Number) {
    match n.value {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("{}", n.value),
    }
}
```

ë©”ì†Œë“œëŠ” ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸í•©ë‹ˆë‹¤.

```rust
struct Number {
    odd: bool,
    value: i32,
}

impl Number {
    fn is_strictly_positive(self) -> bool {
        self.value > 0
    }
}
```

ê°ì²´ í• ë‹¹ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë¶ˆë³€ì…ë‹ˆë‹¤. ê°ì²´ì˜ ë‚´ë¶€ë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

```rust
fn main() {
    let minus_two = Number {
        odd: false,
        value: -2,
    };
    println!("positive? {}", minus_two.is_strictly_positive());
    // this prints "positive? false"
}
```

ìƒˆ ê°ì²´ë¥¼ ê°™ì€ ì´ë¦„ì— í• ë‹¹í•˜ëŠ” ê²ƒë„ ê¸ˆì§€ë©ë‹ˆë‹¤.

```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n = Number {
        odd: false,
        value: 22,
    }; // error: cannot assign twice to immutable variable `n`
}
```

`mut` í‚¤ì›Œë“œë¥¼ í†µí•´, ê°€ë³€ ê°ì²´ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    }
    n.value = 19; // all good
}

```

`trait`ì„ í†µí•´ íƒ€ì…ë“¤ì´ ê³µí†µì ìœ¼ë¡œ ê°–ëŠ” ë™ì‘ì„ ì¶”ìƒí™”í•©ë‹ˆë‹¤.

```rust
trait Signed {
    fn is_strictly_negative(self) -> bool;
}
```

ì•„ë˜ëŠ” traitì˜ ì˜ˆì‹œì…ë‹ˆë‹¤.

```rust
impl Signed for Number {
    fn is_strictly_negative(self) -> bool {
        self.value < 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!("{}", n.is_strictly_negative()); // prints "true"
}
```

ì›ì‹œ íƒ€ì…ì—ë„ ì ìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
impl Signed for i32 {
    fn is_strictly_negative(self) -> bool {
        self < 0
    }
}

fn main() {
    let n: i32 = -44;
    println!("{}", n.is_strictly_negative()); // prints "true"
}
```

ì•„ë˜ëŠ” ì™¸ë¶€ì— ì •ì˜ëœ `Neg` traitì„ í†µí•´, ì—°ì‚°ì ì˜¤ë²„ë¡œë”©ì„ êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤.

```rust
// the `Neg` trait is used to overload `-`, the
// unary minus operator.
impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -> Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // this is only possible because we implemented `Neg`
    println!("{}", m.value); // prints "-987"
}
```

`impl` ë¸”ë¡ ì•ˆì—ì„œ `Self`ëŠ” typeì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

```rust
impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -> Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }
    }
}
```

trait ì¤‘ì— ì¼ë¶€ëŠ” <i>marker</i>ì…ë‹ˆë‹¤.  
markerë€ ì•ˆì „í•˜ì§€ ì•Šì€ (unsafe) ì½”ë“œë¥¼ í¬í•¨í•œ traitì„ ë§í•©ë‹ˆë‹¤.
ì•ˆì „í•˜ì§€ ì•Šì€ ì½”ë“œë€ ë©”ëª¨ë¦¬ì— ì§ì ‘ ì ‘ê·¼í•˜ê±°ë‚˜ í”Œë«í¼ì— ì˜ì¡´ì ì¸ ì½”ë“œë¥¼ ë§í•©ë‹ˆë‹¤.

Some traits are markers - they don't say that a type implements some methods, they say that certain things can be done with a type.

ì˜ˆë¥¼ ë“¤ì–´ì„œ `i32`ëŠ” `Copy` traitì„ ê°€ì§‘ë‹ˆë‹¤.

```rust
fn main() {
    let a: i32 = 15;
    let b = a; // `a` is copied
    let c = a; // `a` is copied again
}
```

ì•„ë˜ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
fn print_i32(x: i32) {
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}

```

ê·¸ëŸ¬ë‚˜ `Number` êµ¬ì¡°ì²´ëŠ” `Copy`ë¥¼ ê°–ì§€ ì•ŠìŠµë‹ˆë‹¤.
ë”°ë¼ì„œ ì•„ë˜ëŠ” ë™ì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `n` is moved into `m`
    let o = n; // error: use of moved value: `n`
}
```

ì•„ë˜ ë˜í•œ ë™ì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```rust
fn print_number(n: Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // `n` is moved
    print_number(n); // error: use of moved value: `n`
}

```

í•˜ì§€ë§Œ ë§Œì•½ `print_number`ê°€ ë¶ˆë³€ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì¸ìë¡œ ë°›ëŠ”ë‹¤ë©´ ë™ì‘í•©ë‹ˆë‹¤.

```rust
fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&n); // `n` is borrowed for the time of the call
    print_number(&n); // `n` is borrowed again
}
```

ë§Œì•½ ì¸ìê°€ ê°€ë³€ ë ˆí¼ëŸ°ìŠ¤ì—¬ë„ ë™ì‘í•©ë‹ˆë‹¤.

```rust
fn invert(n: &mut Number) {
    n.value = -n.value;
}

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    // this time, `n` is mutable
    let mut n = Number { odd: true, value: 51 };
    print_number(&n);
    invert(&mut n); // `n is borrowed mutably - everything is explicit
    print_number(&n);
}

```

Trait ë©”ì†Œë“œëŠ” `self`ë¥¼ ë¶ˆë³€ ë° ê°€ë³€ ë ˆí¼ëŸ°ìŠ¤ë¡œ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```rust
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}
```

When invoking trait methods, the receiver is borrowed implicitly:

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone();
    m.value += 100;

    print_number(&n);
    print_number(&m);
}

```

ì•„ë˜ì˜ ë‘ ì¤„ì€ ì„œë¡œ ê°™ìŠµë‹ˆë‹¤.

```rust
let m = n.clone();

let m = std::clone::Clone::clone(&n);
```

Marker traits like `Copy` have no methods:

```rust
// note: `Copy` requires that `Clone` is implemented too
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
```

`Copy`ì˜ êµ¬í˜„ì´ ë¹„ì›Œì ¸ë„ `Clone`ì€ ì—¬ì „íˆ ì‚¬ìš©ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n.clone();
    let o = n.clone();
}
```

ê·¸ëŸ¬ë‚˜ `Number`ì˜ ê°’ì€ ë” ì´ìƒ ì´ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `m` is a copy of `n`
    let o = n; // same. `n` is neither moved nor borrowed.
}

```

Some traits are so common, they can be implemented automatically by using the `derive` attribute:

```rust
#[derive(Clone, Copy)]
struct Number {
    odd: bool,
    value: i32,
}

// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.
```

Functions can be generic:

```rust
fn foobar<T>(arg: T) {
    // do something with `arg`
}
```

They can have multiple type parameters, which can then be used in the function's declaration and its body, instead of concrete types:

```rust
fn foobar<L, R>(left: L, right: R) {
    // do something with `left` and `right`
}
```

Type parameters usually have constraints, so you can actually do something with them.

The simplest constraints are just trait names:

```rust
fn print<T: Display>(value: T) {
    println!("value = {}", value);
}

fn print<T: Debug>(value: T) {
    println!("value = {:?}", value);
}
```

There's a longer syntax for type parameter constraints:

```rust
fn print<T>(value: T)
where
    T: Display,
{
    println!("value = {}", value);
}
```

Constraints can be more complicated: they can require a type parameter to implement multiple traits:

```rust
use std::fmt::Debug;

fn compare<T>(left: T, right: T)
where
    T: Debug + PartialEq,
{
    println!("{:?} {} {:?}", left, if left == right { "==" } else { "!=" }, right);
}

fn main() {
    compare("tea", "coffee");
    // prints: "tea" != "coffee"
}
```

Generic functions can be thought of as namespaces, containing an infinity of functions with different concrete types.

Same as with crates, and modules, and types, generic functions can be "explored" (navigated?) using `::`

```rust
fn main() {
    use std::any::type_name;
    println!("{}", type_name::<i32>()); // prints "i32"
    println!("{}", type_name::<(f64, char)>()); // prints "(f64, char)"
}
```

This is lovingly called [turbofish syntax](https://turbo.fish/), because `::<>` looks like a fish.

Structs can be generic too:

```rust
struct Pair<T> {
    a: T,
    b: T,
}

fn print_type_name<T>(_val: &T) {
    println!("{}", std::any::type_name::<T>());
}

fn main() {
    let p1 = Pair { a: 3, b: 9 };
    let p2 = Pair { a: true, b: false };
    print_type_name(&p1); // prints "Pair<i32>"
    print_type_name(&p2); // prints "Pair<bool>"
}

```

The standard library type `Vec` (~ a heap-allocated array), is generic:

```rust
fn main() {
    let mut v1 = Vec::new();
    v1.push(1);
    let mut v2 = Vec::new();
    v2.push(false);
    print_type_name(&v1); // prints "Vec<i32>"
    print_type_name(&v2); // prints "Vec<bool>"
}
```

Speaking of `Vec`, it comes with a macro that gives more or less "vec literals":

```rust
fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![true, false, true];
    print_type_name(&v1); // prints "Vec<i32>"
    print_type_name(&v2); // prints "Vec<bool>"
}

```

All of `name!()`, `name![]` or `name!{}` invoke a macro. Macros just expand to regular code.

In fact, `println` is a macro:

```rust
fn main() {
    println!("{}", "Hello there!");
}
```

This expands to something that has the same effect as:

```rust
fn main() {
    use std::io::{self, Write};
    io::stdout().lock().write_all(b"Hello there!\n").unwrap();
}
```

`panic` is also a macro. It violently stops execution with an error message, and the file name / line number of the error, if enabled:

```rust
fn main() {
    panic!("This panics");
}
// output: thread 'main' panicked at 'This panics', src/main.rs:3:5
```

Some methods also panic. For example, the `Option` type can contain something, or it can contain nothing. If `.unwrap()` is called on it, and it contains nothing, it panics:

```rust
fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // this is fine

    let o2: Option<i32> = None;
    o2.unwrap(); // this panics!
}

// output: thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21
```

`Option` is not a struct - it's an `enum`, with two variants.

```rust
enum Option<T> {
    None,
    Some(T),
}

impl<T> Option<T> {
    fn unwrap(self) -> T {
        // enums variants can be used in patterns:
        match self {
            Self::Some(t) => t,
            Self::None => panic!(".unwrap() called on a None option"),
        }
    }
}

use self::Option::{None, Some};

fn main() {
    let o1: Option<i32> = Some(128);
    o1.unwrap(); // this is fine

    let o2: Option<i32> = None;
    o2.unwrap(); // this panics!
}

// output: thread 'main' panicked at '.unwrap() called on a None option', src/main.rs:11:27
```

`Result` is also an enum, it can either contain something, or an error:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

It also panics when unwrapped and containing an error.

Variables bindings have a "lifetime":

```rust
fn main() {
    // `x` doesn't exist yet
    {
        let x = 42; // `x` starts existing
        println!("x = {}", x);
        // `x` stops existing
    }
    // `x` no longer exists
}
```

Similarly, references have a lifetime:

```rust
fn main() {
    // `x` doesn't exist yet
    {
        let x = 42; // `x` starts existing
        let x_ref = &x; // `x_ref` starts existing - it borrows `x`
        println!("x_ref = {}", x_ref);
        // `x_ref` stops existing
        // `x` stops existing
    }
    // `x` no longer exists
}
```

The lifetime of a reference cannot exceed the lifetime of the variable binding it borrows:

```rust
fn main() {
    let x_ref = {
        let x = 42;
        &x
    };
    println!("x_ref = {}", x_ref);
    // error: `x` does not live long enough
}
```

A variable binding can be immutably borrowed multiple times:

```rust
fn main() {
    let x = 42;
    let x_ref1 = &x;
    let x_ref2 = &x;
    let x_ref3 = &x;
    println!("{} {} {}", x_ref1, x_ref2, x_ref3);
}
```

While borrowed, a variable binding cannot be mutated:

```rust
fn main() {
    let mut x = 42;
    let x_ref = &x;
    x = 13;
    println!("x_ref = {}", x_ref);
    // error: cannot assign to `x` because it is borrowed
}
```

While immutably borrowed, a variable cannot be mutably borrowed:

```rust
fn main() {
    let mut x = 42;
    let x_ref1 = &x;
    let x_ref2 = &mut x;
    // error: cannot borrow `x` as mutable because it is also borrowed as immutable
    println!("x_ref1 = {}", x_ref1);
}
```

References in function arguments also have lifetimes:

```rust
fn print(x: &i32) {
    // `x` is borrowed (from the outside) for the
    // entire time this function is called.
}
```

Functions with reference arguments can be called with borrows that have different lifetimes, so:

- All functions that take references are generic
- Lifetimes are generic parameters

Lifetimes' names start with a single quote, `'`:

```rust
// elided (non-named) lifetimes:
fn print(x: &i32) {}

// named lifetimes:
fn print<'a>(x: &'a i32) {}
```

This allows returning references whose lifetime depend on the lifetime of the arguments:

```rust
struct Number {
    value: i32,
}

fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn main() {
    let n = Number { value: 47 };
    let v = number_value(&n);
    // `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.
    // While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.
}
```

When there is a single input lifetime, it doesn't need to be named, and everything has the same lifetime, so the two functions below are equivalent:

```rust
fn number_value<'a>(num: &'a Number) -> &'a i32 {
    &num.value
}

fn number_value(num: &Number) -> &i32 {
    &num.value
}
```

Structs can also be generic over lifetimes, which allows them to hold references:

```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn main() {
    let x: i32 = 99;
    let x_ref = NumRef { x: &x };
    // `x_ref` cannot outlive `x`, etc.
}
```

The same code, but with an additional function:

```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref<'a>(x: &'a i32) -> NumRef<'a> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // `x_ref` cannot outlive `x`, etc.
}
```

The same code, but with "elided" lifetimes:

```rust
struct NumRef<'a> {
    x: &'a i32,
}

fn as_num_ref(x: &i32) -> NumRef<'_> {
    NumRef { x: &x }
}

fn main() {
    let x: i32 = 99;
    let x_ref = as_num_ref(&x);
    // `x_ref` cannot outlive `x`, etc.
}
```

`impl` blocks can be generic over lifetimes too:

```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&'a self) -> &'a i32 {
        self.x
    }
}

fn main() {
    let x: i32 = 99;
    let x_num_ref = NumRef { x: &x };
    let x_i32_ref = x_num_ref.as_i32_ref();
    // neither ref can outlive `x`
}
```

But you can do elision ("to elide") there too:

```rust
impl<'a> NumRef<'a> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}

```

You can elide even harder, if you never need the name:

```rust
impl NumRef<'_> {
    fn as_i32_ref(&self) -> &i32 {
        self.x
    }
}
```

There is a special lifetime, named `'static`, which is valid for the entire program's lifetime.

String literals are `'static`:

```rust
struct Person {
    name: &'static str,
}

fn main() {
    let p = Person {
        name: "fasterthanlime",
    };
}
```

But owned strings are not static:

```rust
struct Person {
    name: &'static str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // error: `name` does not live long enough
}
```

In that last example, the local `name` is not a `&'static str`, it's a `String`.
It's been allocated dynamically, and it will be freed.
Its lifetime is less than the whole program (even though it happens to be in `main`).

To store a non-`'static` string in `Person`, it needs to either:

A) Be generic over a lifetime:

```rust
struct Person<'a> {
    name: &'a str,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: &name };
    // `p` cannot outlive `name`
}
```

or

B) Take ownership of the string

```rust
struct Person {
    name: String,
}

fn main() {
    let name = format!("fasterthan{}", "lime");
    let p = Person { name: name };
    // `name` was moved into `p`, their lifetimes are no longer tied.
}
```

Speaking of: in a struct literal, when a field is set to a variable binding of the same name:

```rust
    let p = Person { name: name };
```

It can be shortened like this:

```rust
    let p = Person { name };
```

For many types in Rust, there are owned and non-owned variants:

- Strings: `String` is owned, `&str` is a reference
- Paths: `PathBuf` is owned, `&Path` is a reference
- Collections: `Vec<T>` is owned, `&[T]` is a reference

Rust has slices - they're a reference to multiple contiguous elements.

You can borrow a slice of a vector, for example:

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let v2 = &v[2..4];
    println!("v2 = {:?}", v2);
}

// output:
// v2 = [3, 4]
```

The above is not magical. The indexing operator (`foo[index]`) is overloaded with the `Index` and `IndexMut` traits.

The `..` syntax is just range literals. Ranges are just a few structs defined in the standard library.

They can be open-ended, and their rightmost bound can be inclusive, if it's preceded by `=`.

```rust
fn main() {
    // 0 or greater
    println!("{:?}", (0..).contains(&100)); // true
    // strictly less than 20
    println!("{:?}", (..20).contains(&20)); // false
    // 20 or less than 20
    println!("{:?}", (..=20).contains(&20)); // true
    // only 3, 4, 5
    println!("{:?}", (3..6).contains(&4)); // true
}
```

Borrowing rules apply to slices.

```rust
fn tail(s: &[u8]) -> &[u8] {
  &s[1..]
}

fn main() {
    let x = &[1, 2, 3, 4, 5];
    let y = tail(x);
    println!("y = {:?}", y);
}
```

This is the same as:

```rust
fn tail<'a>(s: &'a [u8]) -> &'a [u8] {
  &s[1..]
}
```

This is legal:

```rust
fn main() {
    let y = {
        let x = &[1, 2, 3, 4, 5];
        tail(x)
    };
    println!("y = {:?}", y);
}
```

...but only because `[1, 2, 3, 4, 5]` is a `'static` array.

So, this is illegal:

```rust
fn main() {
    let y = {
        let v = vec![1, 2, 3, 4, 5];
        tail(&v)
        // error: `v` does not live long enough
    };
    println!("y = {:?}", y);
}
```

...because a vector is heap-allocated, and it has a non-`'static` lifetime.

`&str` values are really slices.

```rust
fn file_ext(name: &str) -> Option<&str> {
    // this does not create a new string - it returns
    // a slice of the argument.
    name.split(".").last()
}

fn main() {
    let name = "Read me. Or don't.txt";
    if let Some(ext) = file_ext(name) {
        println!("file extension: {}", ext);
    } else {
        println!("no file extension");
    }
}
```

...so the borrow rules apply here too:

```rust
fn main() {
    let ext = {
        let name = String::from("Read me. Or don't.txt");
        file_ext(&name).unwrap_or("")
        // error: `name` does not live long enough
    };
    println!("extension: {:?}", ext);
}
```

Functions that can fail typically return a `Result`:

```rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]);
    println!("{:?}", s);
    // prints: Ok("ğŸ‰")

    let s = std::str::from_utf8(&[195, 40]);
    println!("{:?}", s);
    // prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })
}
```

If you want to panic in case of failure, you can .unwrap():

```rust
fn main() {
    let s = std::str::from_utf8(&[240, 159, 141, 137]).unwrap();
    println!("{:?}", s);
    // prints: "ğŸ‰"

    let s = std::str::from_utf8(&[195, 40]).unwrap();
    // prints: thread 'main' panicked at 'called `Result::unwrap()`
    // on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }',
    // src/libcore/result.rs:1165:5
}
```

Or `.expect()`, for a custom message:

```rust
fn main() {
    let s = std::str::from_utf8(&[195, 40]).expect("valid utf-8");
    // prints: thread 'main' panicked at 'valid utf-8: Utf8Error
    // { valid_up_to: 0, error_len: Some(1) }', src/libcore/result.rs:1165:5
}
```

Or, you can `match`:

```rust
fn main() {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => panic!(e),
    }
    // prints ğŸ‰
}
```

Or you can `if let`:

```rust
fn main() {
    if let Ok(s) = std::str::from_utf8(&[240, 159, 141, 137]) {
        println!("{}", s);
    }
    // prints ğŸ‰
}
```

Or you can bubble up the error:

```rust
fn main() -> Result<(), std::str::Utf8Error> {
    match std::str::from_utf8(&[240, 159, 141, 137]) {
        Ok(s) => println!("{}", s),
        Err(e) => return Err(e),
    }
    Ok(())
}
```

Or you can use `?` to do it the concise way:

```rust
fn main() -> Result<(), std::str::Utf8Error> {
    let s = std::str::from_utf8(&[240, 159, 141, 137])?;
    println!("{}", s);
    Ok(())
}
```

The `*` operator can be used to <i>dereference</i>, but you don't need to do that to access fields or call methods:

```rust
struct Point {
    x: f64,
    y: f64,
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;
    println!("({}, {})", p_ref.x, p_ref.y);
}

// prints `(1, 3)`
```

And you can only do it if the type is `Copy`:

```rust
struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -> Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;
    negate(*p_ref);
    // error: cannot move out of `*p_ref` which is behind a shared reference
}
```

```rust
// now `Point` is `Copy`
#[derive(Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

fn negate(p: Point) -> Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

fn main() {
    let p = Point { x: 1.0, y: 3.0 };
    let p_ref = &p;
    negate(*p_ref); // ...and now this works
}
```

Closures are just functions of type `Fn`, `FnMut` or `FnOnce` with some captured context.

Their parameters are a comma-separated list of names within a pair of pipes (`|`).
They don't need curly braces, unless you want to have multiple statements.

```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}

fn main() {
    for_each_planet(|planet| println!("Hello, {}", planet));
}

// prints:
// Hello, Earth
// Hello, Mars
// Hello, Jupiter
```

The borrow rules apply to them too:

```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str)
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}

fn main() {
    let greeting = String::from("Good to see you");
    for_each_planet(|planet| println!("{}, {}", greeting, planet));
    // our closure borrows `greeting`, so it cannot outlive it
}
```

For example, this would not work:

```rust
fn for_each_planet<F>(f: F)
    where F: Fn(&'static str) + 'static // `F` must now have "'static" lifetime
{
    f("Earth");
    f("Mars");
    f("Jupiter");
}

fn main() {
    let greeting = String::from("Good to see you");
    for_each_planet(|planet| println!("{}, {}", greeting, planet));
    // error: closure may outlive the current function, but it borrows
    // `greeting`, which is owned by the current function
}
```

But this would:

```rust
fn main() {
    let greeting = String::from("You're doing great");
    for_each_planet(move |planet| println!("{}, {}", greeting, planet));
    // `greeting` is no longer borrowed, it is *moved* into
    // the closure.
}
```

An `FnMut` needs to be mutably borrowed to be called, so it can only be called once at a time.

This is legal:

```rust
fn foobar<F>(f: F)
    where F: Fn(i32) -> i32
{
    println!("{}", f(f(2)));
}

fn main() {
    foobar(|x| x * 2);
}

// output: 8
```

This isn't:

```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    println!("{}", f(f(2)));
    // error: cannot borrow `f` as mutable more than once at a time
}

fn main() {
    foobar(|x| x * 2);
}
```

This is legal again:

```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    let tmp = f(2);
    println!("{}", f(tmp));
}

fn main() {
    foobar(|x| x * 2);
}

// output: 8
```

`FnMut` exists because some closures mutably borrow local variables:

```rust
fn foobar<F>(mut f: F)
    where F: FnMut(i32) -> i32
{
    let tmp = f(2);
    println!("{}", f(tmp));
}

fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        x * acc
    });
}

// output: 24
```

Those closures cannot be passed to functions expecting `Fn`:

```rust
fn foobar<F>(f: F)
    where F: Fn(i32) -> i32
{
    println!("{}", f(f(2)));
}

fn main() {
    let mut acc = 2;
    foobar(|x| {
        acc += 1;
        // error: cannot assign to `acc`, as it is a
        // captured variable in a `Fn` closure.
        // the compiler suggests "changing foobar
        // to accept closures that implement `FnMut`"
        x * acc
    });
}
```

`FnOnce` closures can only be called once. They exist because some closure move out variables that have been moved when captured:

```rust
fn foobar<F>(f: F)
    where F: FnOnce() -> String
{
    println!("{}", f());
}

fn main() {
    let s = String::from("alright");
    foobar(move || s);
    // `s` was moved into our closure, and our
    // closures moves it to the caller by returning
    // it. Remember that `String` is not `Copy`.
}
```

This is enforced naturally, as `FnOnce` closures need to be <i>moved</i> in order to be called.

So, for example, this is illegal:

```rust
fn foobar<F>(f: F)
    where F: FnOnce() -> String
{
    println!("{}", f());
    println!("{}", f());
    // error: use of moved value: `f`
}
```

And, if you need convincing that our closure <i>does</i> move `s`, this is illegal too:

```rust
fn main() {
    let s = String::from("alright");
    foobar(move || s);
    foobar(move || s);
    // use of moved value: `s`
}
```

But this is fine:

```rust
fn main() {
    let s = String::from("alright");
    foobar(|| s.clone());
    foobar(|| s.clone());
}
```

Here's a closure with two arguments:

```rust
fn foobar<F>(x: i32, y: i32, is_greater: F)
    where F: Fn(i32, i32) -> bool
{
    let (greater, smaller) = if is_greater(x, y) {
        (x, y)
    } else {
        (y, x)
    };
    println!("{} is greater than {}", greater, smaller);
}

fn main() {
    foobar(32, 64, |x, y| x > y);
}
```

Here's a closure ignoring both its arguments:

```rust
fn main() {
    foobar(32, 64, |_, _| panic!("Comparing is futile!"));
}
```

Here's a slightly worrying closure:

```rust
fn countdown<F>(count: usize, tick: F)
    where F: Fn(usize)
{
    for i in (1..=count).rev() {
        tick(i);
    }
}

fn main() {
    countdown(3, |i| println!("tick {}...", i));
}

// output:
// tick 3...
// tick 2...
// tick 1...
```

And here's a toilet closure:

```rust
fn main() {
    countdown(3, |_| ());
}
```

Called thusly because `|_| ()` looks like a toilet.

Anything that is iterable can be used in a `for in` loop.

We've just seen a range being used, but it also works with a `Vec`:

```rust
fn main() {
    for i in vec![52, 49, 21] {
        println!("I like the number {}", i);
    }
}
```

Or a slice:

```rust
fn main() {
    for i in &[52, 49, 21] {
        println!("I like the number {}", i);
    }
}

// output:
// I like the number 52
// I like the number 49
// I like the number 21
```

Or an actual iterator:

```rust
fn main() {
    // note: `&str` also has a `.bytes()` iterator.
    // Rust's `char` type is a "Unicode scalar value"
    for c in "rust".chars() {
        println!("Give me a {}", c);
    }
}

// output:
// Give me a r
// Give me a u
// Give me a s
// Give me a t
```

Even if the iterator items are filtered and mapped and flattened:

```rust
fn main() {
    for c in "SuRPRISE INbOUND"
        .chars()
        .filter(|c| c.is_lowercase())
        .flat_map(|c| c.to_uppercase())
    {
        print!("{}", c);
    }
    println!();
}

// output: UB
```

You can return a closure from a function:

```rust
fn make_tester(answer: String) -> impl Fn(&str) -> bool {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    // you can use `.into()` to perform conversions
    // between various types, here `&'static str` and `String`
    let test = make_tester("hunter2".into());
    println!("{}", test("******"));
    println!("{}", test("hunter2"));
}
```

You can even move a reference to some of a function's arguments, into a closure it returns:

```rust
fn make_tester<'a>(answer: &'a str) -> impl Fn(&str) -> bool + 'a {
    move |challenge| {
        challenge == answer
    }
}

fn main() {
    let test = make_tester("hunter2");
    println!("{}", test("*******"));
    println!("{}", test("hunter2"));
}

// output:
// false
// true
```

Or, with elided lifetimes:

```rust
fn make_tester(answer: &str) -> impl Fn(&str) -> bool + '_ {
    move |challenge| {
        challenge == answer
    }
}
```

And with that, we hit the 30-minute estimated reading time mark, and you should be able to read <i>most</i> of the Rust code you find online.

Writing Rust is a very different experience from reading Rust. On one hand, you're not reading the <i>solution</i> to a problem, you're actually solving it. On the other hand, the Rust compiler helps out a <i>lot</i>.

For all of the intentional mistakes made above ("this code is illegal", etc.), rustc always has very good error messages and insightful suggestions.

And when there's a hint missing, the compiler team [is not afraid to add it](https://mobile.twitter.com/fasterthanlime/status/1219601989404954624).

For more Rust material, you may want to check out:

- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust By Example](https://doc.rust-lang.org/stable/rust-by-example/)
- [Read Rust](https://readrust.net/)
- [This Week In Rust](https://this-week-in-rust.org/)

I also blog about Rust and tweet about Rust a lot, so if you liked this article, you know what to do.

Have fun!

### ì°¸ê³ ë¬¸í—Œ

- Amos Wenger, <i>A half-hour to learn Rust.</i> https://fasterthanli.me/articles/a-half-hour-to-learn-rust
- Nicholas Matsakis, <i>The Rust Programming Language.</i> https://doc.rust-lang.org/book/
