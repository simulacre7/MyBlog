---
title: '30분만에 배우는 Rust'
date: '2022-04-02'
tags: ['rust', 'browser', 'low-level']
draft: false
summary: 'Rust에 빠르게 입문해보자!'
layout: PostSimple
bibliography: /half-hour-rust/half-hour-rust.bib
canonicalUrl: https://tailwind-nextjs-starter-blog.vercel.app/blog/half-hour-rust/
---

> 다음 글은 Amos Wenger의 [A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)를 번역한 것입니다.
> 물론 저자에게 허락을 받았습니다.
> 번역문 뒤의 참고문헌은 제가 작성했습니다.

이 글에서 최대한 많은 Rust 코드 조각들을 다루고자 합니다.
독자들은 Rust의 수 많은 키워드와 기호가 각각 어떤 의미를 갖는지 알게 될 것이고,
온라인에서 마주치는 대부분의 Rust 코드를 이해할 수 있게 될 것입니다.

let은 변수를 선언합니다:

```rust
let x; // declare "x"
x = 42; // assign 42 to "x"
```

한 줄로 줄여쓸 수도 있습니다:

```rust
let x = 42;
```

`:`로 타입을 명시할 수 있습니다. 이를 type annotation이라고 부릅니다.

```rust
let x: i32; // `i32` is a signed 32-bit integer
x = 42;

// there's i8, i16, i32, i64, i128
//    also u8, u16, u32, u64, u128 for unsigned
```

이것 또한 한 줄로 줄여쓸 수 있습니다.

```rust
let x: i32 = 42;
```

변수의 값을 초기화하기도 전에 그 변수를 호출한다면 컴파일러가 에러를 일으킵니다.

```rust
let x;
foobar(x); // error: borrow of possibly-uninitialized variable: `x`
x = 42;
```

아래와 같이 초기화를 먼저해야 합니다.

```rust
let x;
x = 42;
foobar(x); // the type of `x` will be inferred from here
```

밑줄 기호(undersocre) `_`로 변수 이름을 지으면 값을 무시합니다.

```rust
// this does *nothing* because 42 is a constant
let _ = 42;

// this calls `get_thing` but throws away its result
let _ = get_thing();
```

이름이 `_`로 <i>시작</i>하는 경우, 위와는 다르게 동작합니다.
이 용법은 컴파일러가 이 변수가 사용되지 않더라도 경고하지 않게끔 합니다.

```rust
// we may use `_x` eventually, but our code is a work-in-progress
// and we just wanted to get rid of a compiler warning for now.
let _x = 42;
```

아래와 같은 경우를 <i>shadow</i>라고 합니다.

```rust
let x = 13;
let x = x + 3;
// using `x` after that line only refers to the second `x`,
// the first `x` no longer exists.
```

Rust에는 튜플(tuples) 자료구조가 있습니다. 튜플은 "길이가 고정된, 여러 타입들의 값들의 집합"입니다.

```rust
let pair = ('a', 17);
pair.0; // this is 'a'
pair.1; // this is 17
```

`pair`의 타입을 명시하고 싶다면, 아래와 같이 쓰면 됩니다.

```rust
let pair: (char, i32) = ('a', 17);
```

튜플은 구조 분해 할당(destructuring assignment)가 가능합니다.

```rust
let (some_char, some_int) = ('a', 17);
// now, `some_char` is 'a', and `some_int` is 17
```

구조 분해 할당은 어떤 함수가 튜플을 리턴할 때 유용합니다.

```rust
let (left, right) = slice.split_at(middle);
```

구조 분해 할당을 할 때, `_`을 사용해서 튜플의 일부를 무시할 수 있습니다.

```rust
let (_, right) = slice.split_at(middle);
```

세미 콜론은 `;` 문장(statement)의 끝을 의미합니다.

```rust
let x = 3;
let y = 5;
let z = y + x;
```

이 말인즉슨 한 문장은 여러 줄을 가질 수 있습니다.
아래 코드가 실제로 어떤 의미를 갖는지는 조금 있다가 다루겠습니다.

```rust
let x = vec![1, 2, 3, 4, 5, 6, 7, 8]
    .iter()
    .map(|x| x + 3)
    .fold(0, |x, y| x + y);
```

`fn`은 함수를 선언합니다.

```rust
fn greet() {
    println!("Hi there!");
}
```

화살표 `->` 기호를 통해 return 타입을 명시할 수 있습니다.

```rust
fn fair_dice_roll() -> i32 {
    4
}
```

한 쌍의 중괄호로 block을 선언합니다. block은 고유의 scope를 가집니다.

```rust
// This prints "in", then "out"
fn main() {
    let x = "out";
    {
        // this is a different `x`
        let x = "in";
        println!("{}", x);
    }
    println!("{}", x);
}
```

Block은 표현식이기도 합니다. 이 말인즉슨 block은 결과값을 반환합니다.

```rust
// this:
let x = 42;

// is equivalent to this:
let x = { 42 };
```

한 block 안에서 여러 개의 문장이 있을 수 있습니다.

```rust
let x = {
    let y = 1; // first statement
    let z = 2; // second statement
    y + z // this is the *tail* - what the whole block will evaluate to
};
```

함수의 마지막 부분에서 세미콜론을 생략하는 것은 return을 의미합니다.
따라서 아래의 두 함수는 똑같이 동작합니다.

```rust
fn fair_dice_roll() -> i32 {
    return 4;
}

fn fair_dice_roll() -> i32 {
    4
}
```

`if` 조건문 또한 표현식(expression)입니다.

```rust
fn fair_dice_roll() -> i32 {
    if feeling_lucky {
        6
    } else {
        4
    }
}
```

`match` 또한 표현식입니다.

```rust
fn fair_dice_roll() -> i32 {
    match feeling_lucky {
        true => 6,
        false => 4,
    }
}
```

점(`.`)은 field의 값을 접근하기 위해 사용됩니다.

```rust
let a = (10, 20);
a.0; // this is 10

let amos = get_some_struct();
amos.nickname; // this is "fasterthanlime"
```

또는 메소드를 부르기 위해 사용됩니다.

```rust
let nick = "fasterthanlime";
nick.len(); // this is 14
```

Double-colon `::`은 점과 비슷하지만 네임스페이스로 동작합니다.

아래 예시에서, `std`는 <i>crate</i>(라이브러리와 유사한 개념)이고, `cmp`는 <i>module</i>이고 `min`은 함수이다.

```rust
let least = std::cmp::min(3, 8); // this is 3
```

`use`를 통해, 이름을 간결하게 가져올 수 있습니다.

```rust
use std::cmp::min;

let least = min(7, 1); // this is 1
```

`use`를 쓸 때, 중괄호는 또 다른 의미를 가집니다.

```rust
// this works:
use std::cmp::min;
use std::cmp::max;

// this also works:
use std::cmp::{min, max};

// this also works!
use std::{cmp::min, cmp::max};
```

와일드카드(`*`)를 통해, 네임스페이스의 모든 요소를 가져올 수 있습니다.

```rust
// this brings `min` and `max` in scope, and many other things
use std::cmp::*;
```

타입 또한 네임스페이스입니다. 따라서 타입의 메소드는 일반적인 함수처럼 호출될 수 있습니다.

```rust
let x = "amos".len(); // this is 4
let x = str::len("amos"); // this is also 4
```

`str`은 원시 타입이지만, 원시 타입이 아닌 타입들도 다음과 같이 활용이 가능합니다.

```rust
// `Vec` is a regular struct, not a primitive type
let v = Vec::new();

// this is exactly the same code, but with the *full* path to `Vec`
let v = std::vec::Vec::new();
```

위와 같은 일이 가능한 이유는 Rust는 각 모듈에 다음과 같은 코드를 삽입하기 때문입니다.

```rust
use std::prelude::v1::*;
```

(Which in turns re-exports a lot of symbols, like Vec, String, Option and Result).

구조체는 `struct` 키워드로 선언됩니다.

```rust
struct Vec2 {
    x: f64, // 64-bit floating point, aka "double precision"
    y: f64,
}
```

구조체는 구조체 리터럴(strucut literals)을 통해, 값을 초기화할 수 있습니다.

```rust
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, x: 4.0 };
// the order does not matter, only the names do
```

다른 구조체에서 나머지 필드를 초기화하는 편리한 방법이 있습니다.

```rust
let v3 = Vec2 {
    x: 14.0,
    ..v2
};
```

이것을 "struct update syntax"이라고 부릅니다. 맨 마지막 부분에만 활용이 가능하며, 뒤에 `,`가 붙을 수 없습니다.

나머지 필드는 모든 필드를 의미할 수 있습니다.

```rust
let v4 = Vec2 { ..v3 };
```

구조체도 튜플과 마찬가지로 분해가 가능합니다.

```rust
let (left, right) = slice.split_at(middle);
```

아래처럼 분해 할당을 활용할 수 있습니다.

```rust
let v = Vec2 { x: 3.0, y: 6.0 };
let Vec2 { x, y } = v;
// `x` is now 3.0, `y` is now `6.0`
```

구조 분해 할당과 struct update syntax을 같이 쓸 수 있습니다.

```rust
let Vec2 { x, .. } = v;
// this throws away `v.y`
```

`if let` 문법은 `match`와 동일한 목적으로, 더욱 간결하게 쓰입니다.

```rust
struct Number {
    odd: bool,
    value: i32,
}

fn main() {
    let one = Number { odd: true, value: 1 };
    let two = Number { odd: false, value: 2 };
    print_number(one);
    print_number(two);
}

fn print_number(n: Number) {
    if let Number { odd: true, value } = n {
        println!("Odd number: {}", value);
    } else if let Number { odd: false, value } = n {
        println!("Even number: {}", value);
    }
}

// this prints:
// Odd number: 1
// Even number: 2
```

`match`의 조건으로 `if let`을 쓸 수도 있습니다.

```rust
fn print_number(n: Number) {
    match n {
        Number { odd: true, value } => println!("Odd number: {}", value),
        Number { odd: false, value } => println!("Even number: {}", value),
    }
}

// this prints the same as before
```

두 함수는 똑같이 동작합니다. 후자가 훨씬 간결한 표현입니다. `_`을 써서 "catch-all" 패턴이 가능합니다.

```rust
fn print_number(n: Number) {
    match n {
        Number { value: 1, .. } => println!("One"),
        Number { value: 2, .. } => println!("Two"),
        Number { value, .. } => println!("{}", value),
        // if that last arm didn't exist, we would get a compile-time error
    }
}

fn print_number(n: Number) {
    match n.value {
        1 => println!("One"),
        2 => println!("Two"),
        _ => println!("{}", n.value),
    }
}
```

메소드는 아래와 같이 선언합니다.

```rust
struct Number {
    odd: bool,
    value: i32,
}

impl Number {
    fn is_strictly_positive(self) -> bool {
        self.value > 0
    }
}
```

객체 할당은 기본적으로 불변입니다. 객체의 내부를 변경할 수 없습니다.

```rust
fn main() {
    let minus_two = Number {
        odd: false,
        value: -2,
    };
    println!("positive? {}", minus_two.is_strictly_positive());
    // this prints "positive? false"
}
```

새 객체를 같은 이름에 할당하는 것도 금지됩니다.

```rust
fn main() {
    let n = Number {
        odd: true,
        value: 17,
    };
    n = Number {
        odd: false,
        value: 22,
    }; // error: cannot assign twice to immutable variable `n`
}
```

`mut` 키워드를 통해, 가변 객체를 만들 수 있습니다.

```rust
fn main() {
    let mut n = Number {
        odd: true,
        value: 17,
    }
    n.value = 19; // all good
}

```

`trait`을 통해 타입들이 공통적으로 갖는 동작을 추상화합니다.

```rust
trait Signed {
    fn is_strictly_negative(self) -> bool;
}
```

아래는 trait의 예시입니다.

```rust
impl Signed for Number {
    fn is_strictly_negative(self) -> bool {
        self.value < 0
    }
}

fn main() {
    let n = Number { odd: false, value: -44 };
    println!("{}", n.is_strictly_negative()); // prints "true"
}
```

원시 타입에도 적용이 가능합니다.

```rust
impl Signed for i32 {
    fn is_strictly_negative(self) -> bool {
        self < 0
    }
}

fn main() {
    let n: i32 = -44;
    println!("{}", n.is_strictly_negative()); // prints "true"
}
```

아래는 외부에 정의된 `Neg` trait을 통해, 연산자 오버로딩을 구현한 것입니다.

```rust
// the `Neg` trait is used to overload `-`, the
// unary minus operator.
impl std::ops::Neg for Number {
    type Output = Number;

    fn neg(self) -> Number {
        Number {
            value: -self.value,
            odd: self.odd,
        }
    }
}

fn main() {
    let n = Number { odd: true, value: 987 };
    let m = -n; // this is only possible because we implemented `Neg`
    println!("{}", m.value); // prints "-987"
}
```

`impl` 블록 안에서 `Self`는 type을 의미합니다.

```rust
impl std::ops::Neg for Number {
    type Output = Self;

    fn neg(self) -> Self {
        Self {
            value: -self.value,
            odd: self.odd,
        }
    }
}
```

trait 중에 일부는 <i>marker</i>입니다.  
marker란 안전하지 않은 (unsafe) 코드를 포함한 trait을 말합니다.
안전하지 않은 코드란 메모리에 직접 접근하거나 플랫폼에 의존적인 코드를 말합니다.

Some traits are markers - they don't say that a type implements some methods, they say that certain things can be done with a type.

예를 들어서 `i32`는 `Copy` trait을 가집니다.

```rust
fn main() {
    let a: i32 = 15;
    let b = a; // `a` is copied
    let c = a; // `a` is copied again
}
```

아래도 가능합니다.

```rust
fn print_i32(x: i32) {
    println!("x = {}", x);
}

fn main() {
    let a: i32 = 15;
    print_i32(a); // `a` is copied
    print_i32(a); // `a` is copied again
}

```

그러나 `Number` 구조체는 `Copy`를 갖지 않습니다.
따라서 아래는 동작하지 않습니다.

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n; // `n` is moved into `m`
    let o = n; // error: use of moved value: `n`
}
```

아래 또한 동작하지 않습니다.

```rust
fn print_number(n: Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(n); // `n` is moved
    print_number(n); // error: use of moved value: `n`
}

```

하지만 만약 `print_number`가 불변 레퍼런스를 인자로 받는다면 동작합니다.

```rust
fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    let n = Number { odd: true, value: 51 };
    print_number(&n); // `n` is borrowed for the time of the call
    print_number(&n); // `n` is borrowed again
}
```

만약 인자가 가변 레퍼런스여도 동작합니다.

```rust
fn invert(n: &mut Number) {
    n.value = -n.value;
}

fn print_number(n: &Number) {
    println!("{} number {}", if n.odd { "odd" } else { "even" }, n.value);
}

fn main() {
    // this time, `n` is mutable
    let mut n = Number { odd: true, value: 51 };
    print_number(&n);
    invert(&mut n); // `n is borrowed mutably - everything is explicit
    print_number(&n);
}

```

Trait 메소드는 `self`를 불변 및 가변 레퍼런스로 받을 수 있습니다.

```rust
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}
```

When invoking trait methods, the receiver is borrowed implicitly:

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let mut m = n.clone();
    m.value += 100;

    print_number(&n);
    print_number(&m);
}

```

아래의 두 줄은 서로 같습니다.

```rust
let m = n.clone();

let m = std::clone::Clone::clone(&n);
```

Marker traits like `Copy` have no methods:

```rust
// note: `Copy` requires that `Clone` is implemented too
impl std::clone::Clone for Number {
    fn clone(&self) -> Self {
        Self { ..*self }
    }
}

impl std::marker::Copy for Number {}
```

`Copy`의 구현이 비워져도 `Clone`은 여전히 사용이 가능합니다.

```rust
fn main() {
    let n = Number { odd: true, value: 51 };
    let m = n.clone();
    let o = n.clone();
}
```

### 참고문헌

- Amos Wenger, <i>A half-hour to learn Rust.</i> https://fasterthanli.me/articles/a-half-hour-to-learn-rust
- Nicholas Matsakis, <i>The Rust Programming Language.</i> https://doc.rust-lang.org/book/
